装饰者模式总结：
	1、装饰模式使用被装饰类的一个子类的实例，把客户端的调用委派到被装饰类，装饰模式的关键在于这种扩展是完全透明的。
	2、动态给一个对象添加一些额外的职责，就像在墙上刷油漆，使用decorator模式
		相比用生成子类方式达到功能的扩充显得更为灵活。
	3、抽象构件角色（Project）：给出一个接口，以规范准备接收附加责任的对象
	      体构件角色（Employe）：定义一个将要接收附加责任的类
                装饰角色（Manager）：持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口
                具体装饰角色（ManagerA、ManagerB）：负责给构件对象“贴上”附加的责任